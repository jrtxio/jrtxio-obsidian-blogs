---
{"dg-publish":true,"dg-path":"汽车电子/嵌入式系统中的链接脚本解析.md","permalink":"/汽车电子/嵌入式系统中的链接脚本解析/","created":"2022-05-06T15:47:09.000+08:00","updated":"2025-04-02T14:36:32.840+08:00"}
---

#Ofilm #FBL 

在嵌入式系统开发中，链接脚本（Linker Script）是用于控制程序如何组织和分布在存储器中的关键配置文件。它决定了代码段、数据段、堆栈、全局变量等在内存中的具体位置，直接影响系统的启动、运行效率及资源管理。本文将介绍链接脚本的基本概念、语法结构，并结合示例说明其在嵌入式系统中的应用。

# 1. 什么是链接脚本？

链接脚本是由 GNU LD 链接器（GNU Linker，简称 ld）使用的描述文件，通常以 `.ld` 作为后缀。它用于定义目标程序的内存映射、段的组织方式，以及特定符号的地址。对于嵌入式开发来说，特别是在裸机或 RTOS（如 FreeRTOS）环境下，合理设计链接脚本至关重要。

# 2. 链接脚本的基本结构

链接脚本通常由以下部分组成：

1. **ENTRY()** —— 入口地址（可选）
2. **MEMORY** —— 描述物理存储器布局
3. **SECTIONS** —— 定义段的存放方式

## 示例：一个简单的链接脚本

```ld
ENTRY(Reset_Handler)

MEMORY
{
    FLASH (rx)  : ORIGIN = 0x08000000, LENGTH = 512K
    SRAM  (rwx) : ORIGIN = 0x20000000, LENGTH = 128K
}

SECTIONS
{
    .text : 
    {
        *(.isr_vector)
        *(.text)
        *(.rodata)
        . = ALIGN(4);
    } > FLASH

    .data :
    {
        *(.data)
        . = ALIGN(4);
    } > SRAM AT> FLASH

    .bss :
    {
        *(.bss)
        *(COMMON)
        . = ALIGN(4);
    } > SRAM
}
```

# 3. 关键部分解析

## 3.1 ENTRY() —— 程序入口

`ENTRY(Reset_Handler)` 指定了程序的入口地址，通常是复位处理函数 `Reset_Handler`，用于系统启动时的执行位置。

## 3.2 MEMORY —— 定义存储器布局

`MEMORY` 块用于定义芯片上的存储器，如 Flash 和 SRAM：

- Flash（0x08000000 开始，512KB），用于存放代码和只读数据。
- SRAM（0x20000000 开始，128KB），用于存放变量、堆栈等可写数据。

## 3.3 SECTIONS —— 定义段的存放方式

### 代码段（`.text`）

- `*(.isr_vector)`：中断向量表
- `*(.text)`：代码段
- `*(.rodata)`：只读数据

### 数据段（`.data`）

- `*(.data)`：已初始化的全局和静态变量，存放于 SRAM，但初始值存放在 Flash，并由启动代码拷贝到 SRAM。

### BSS 段（`.bss`）

- `*(.bss)`：未初始化的全局和静态变量，启动时清零。

# 4. 链接脚本在嵌入式系统中的作用

1. **内存管理**：合理分配 Flash 和 SRAM，优化资源使用。
2. **启动代码**：确保 `.data` 段正确初始化，`.bss` 段清零。
3. **定制存储策略**：如将特定数据放入特殊存储区（EEPROM、外部 RAM 等）。

# 5. 总结

链接脚本是嵌入式开发的重要组成部分，它决定了程序在存储器中的布局，影响着系统的启动和运行效率。熟练掌握链接脚本的编写技巧，可以有效优化嵌入式系统的内存分配，提高性能和稳定性。