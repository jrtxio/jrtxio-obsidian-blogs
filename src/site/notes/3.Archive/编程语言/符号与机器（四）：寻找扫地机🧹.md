---
{"dg-publish":true,"dg-path":"编程语言/符号与机器（四）：寻找扫地机🧹.md","permalink":"/编程语言/符号与机器（四）：寻找扫地机🧹/","created":"2023-03-05T16:39:15.000+08:00","updated":"2024-12-31T10:05:05.000+08:00"}
---

#Technomous #PLT

> 我们创造机器的目的是为了解决问题，图灵机也只不过是这些大大小小机器中的一个。

# 机器和规则

开始我们定义一套规则来描述机器：

	State Env -> Action NewState

解释如下：状态 周围环境 -> 动作 新状态，即如果机器当前处于【State】状态，并且周围环境是【Env】，那么机器会执行【Action】操作，并将状态更新为【NewState】。用IF语句重写如下：

```
IF (State && Env) {
	Action;
	NewState;
}
```

# 寻找扫地机

问题：有一台扫地机，能够清理地板，并且能识别障碍物。请设计一个机器，能够控制扫地机🧹，使其自动清理房间，并且不会碰到障碍物。

![Pasted image 20230305164124.png|200](/img/user/0.Asset/resource/Pasted%20image%2020230305164124.png)

蓝色-扫地机 棕色-地板 黑色-障碍物

首先我们将问题抽象成上图所示，蓝色表示扫地机，棕色表示地板，黑色表示障碍物。然后根据上面的规则描述，我们定义，

**状态State集合**：{ 0-静止， 1-向上， 2-向下， 3-向左， 4-向右 }

**环境Env集合**：{ x-可通行， U/D/L/R-上/下/左/右不可通行， *-任意 }

注：环境用来描述扫地机上、下、左、右四个位置的情况，比如，
1）UDLR 表示上下左右都不可通行，也就是扫地机周围都是黑色方块
2）x\*\*\* 表示机器人上方可通行，其他方向任意无要求
3）U\*\*\* 表示机器人上方不可通行，其他方向任意无要求~

**动作Action集合**：{ U-向上移动， D-向下移动， L-向左移动， R-向右移动 }

解：机器人初始状态为0-静止，那么，
	定义规则1：0 x\*\*\* -> U 1，表示如果扫地机当前是静止状态，并且上方可移动，那么扫地机向上移动，并将状态更新为向上。
	定义规则2：1 x\*\*\* -> U 1，表示如果扫地机当前是向上状态，并且上方可移动，那么扫地机继续向上移动，并将状态保持为向上。
	
```
0 x*** -> U 1
1 x*** -> U 1
```

这两条规则就创造了一个会一直向上移动的扫地机。虽然这个扫地机很傻，但确确实实是众多扫地机中的一个。如果想看到，这台扫地机的真实效果，可以用下面的扫地机模拟器来执行看看。

# 扫地机生成器

很早之前就写了这个，可以通过定义规则模拟扫地机的应用，放假有时间就完善了一下。欢迎试玩，欢迎提意见，我也会一直优化这个应用。自己动手寻找答案的时候，相信能理解得更深刻吧。

下面两个地址都可以。第二个地址国内访问会慢一些，或者点击阅读原文也能进入。

https://bbit8.gitee.io/sweep-turing-machine
https://bbit8.github.io/sweep-turing-machine

# 图灵机

那么图灵机到底什么？每一个规则集合都对应一个机器，图灵机就是这所有规则集合中的一个。你可以设计出来原地不动的机器，也可以是只会打扫周围地板的扫地机等等。

根据以上推演，我们可以看到最初定义的规则的确可以描述机器。最后，给大家也给我自己留两个问题：

1.  规则的定义是完备的吗，是否还缺少其他元素集合？
2.  如何寻找通用的规则集合？

下次见！

下一篇[[3.Archive/编程语言/符号与机器（五）：重新发明 Lambda 演算\|符号与机器（五）：重新发明 Lambda 演算]]